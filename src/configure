#!/bin/bash

# Basic configuration script
#
# Configures an output directory to build the project for a given target.
# To use:
#
#   # Create a separate output directory and 'cd' to it.
#   mkdir out/i386-elf
#   cd out/i386-elf
#
#   # Configure the project.
#   ../../src/configure --target=i386-elf
#
#   # Make the project
#   make
#
# This will create a Makefile in the output directory, based on
# Makefile.template, with variables set compiling to the given target.
# For example, using a cross-complier toolchange with 'CC = i386-elf-gcc'.

# Stop scripton error.
set -e

# Determine configure script location.
SCRIPT_PATH="${BASH_SOURCE[0]:-$0}"
SCRIPT_NAME="$(basename "$SCRIPT_PATH")"
srcdir="$(dirname "$SCRIPT_PATH")"

# Function to print a warning/error message to stderr
function info {
    echo -e "$SCRIPT_NAME:" "$@"
}
function warn {
    1>&2 echo -e "$SCRIPT_NAME:" "$@"
}

# Process arguments.
while [[ $# -gt 0 ]]; do
    ARG="$1"    # Save current argument
    shift       # Consume current argument
    case "$ARG" in
        -v|--verbose)
            V="verbose"
            ;;
        --target=*)
            target="${ARG##--target=}"
            ;;
        --target)
            target="$1" # The next argument will be the target.
            shift       # Consume that argument too.
            ;;
        *)
            warn "unknown argument \"$ARG\""
            exit 1
            ;;
    esac
done

# Check that source and build directories are different.
if [[ "$(readlink -f "$srcdir")" == "$(readlink -f "$PWD")" ]]; then
    warn "source and build directories should be different"
    warn "create a separate output directory and run this script from there"
    warn "e.g. cd out/i386-elf && ../../src/configure --target=i386-elf"
    exit 1
fi

# Get host architecture triple from gcc, e.g. "x86_64-linux-gnu".
host="$(gcc -dumpmachine)"

# If target is not specified, then default to host architecture.
if [[ -z "$target" ]]; then
    target="$host"
fi

# Get $target_cpu from $target, e.g. "i386" from "i386-elf"
target_cpu=${target%%-*}

# Get $target_os from $target, e.g. "linux" from "x86_64-linux-gnu"
case "$target" in
    *-linux*)   target_os=linux ;;
    *-elf)      target_os=munix ;;  # Generic elf -> our OS.
esac

# Set a Preprocessor macro for our OS, like Linux has __linux__
if [ "$target_os" == "munix" ];
then CPPFLAGS="-D __munix__"
else CPPFLAGS=      # Established target OSs will have predefined macros
fi

# Architecture tweaks
case "$target_cpu" in
    i386)
        # Tweak the "i386" target to compile for a 486 CPU.
        #
        # GCC needs the 486's CMPXCHG instruction to implement <stdatomic.h>
        # atomic integers. If we wanted to support an original 386, we would
        # have to write our own custom implementations of the compare-and-swap
        # functions.
        # It's much easier to simply insist on a 486 by passing this flag:
        TARGET_ARCH=-march=i486
        ;;
esac

# Extra linking flags when compiling for our OS,
# especially load addresses for kernel and processes.
if [ "$target_os" == "munix" ]; then
case "$target_cpu" in
    i386 | x86_64)
        # Put the kernel in the original PC's 640k "low memory",
        # and the processes in the original "high memory" above 1M.
        LDFLAGS_kernel="-Wl,-Ttext-segment 0x10000"
        LDFLAGS_process="-Wl,-Ttext-segment 0x500000"
        ;;
esac
fi

# Find cross compilers
case "$target" in
    "$host") prefixes=("") ;;
    i386-elf | i686-elf) prefixes=(i386-elf- i686-elf-) ;;
    *) prefixes=("$target-")
esac

foundutilkeys=()
foundutilvals=()

function findutil {
    local varname="$1"; shift
    local lprefixes=("${prefixes[@]}")
    if [[ "$1" == "maybeprefix" ]]; then
        lprefixes+=("")
        shift
    fi
    for util in "$@"; do
        read -r -a utilsplit <<< "$util"
        local binname="${utilsplit[0]}"
        for prefix in "${lprefixes[@]}"; do
            if which "$prefix$binname" > /dev/null; then
                info "$(printf "found %-10s = %s\n" "$varname" "$prefix$binname")"
                foundutilkeys+=("$varname")
                foundutilvals+=("$prefix$binname")
                return 0
            fi
        done
    done
    info "could not find an executable for ${lprefixes[0]}$varname"
}

info "searching for compiler tools"
info "checking prefixes: ${prefixes[@]}"
findutil AS as
findutil AR ar
findutil NM nm
findutil OBJDUMP objdump
findutil OBJCOPY objcopy
findutil READELF readelf
findutil CPP    "gcc -E" cpp
findutil CC     gcc cc
findutil CXX    g++ c++
findutil LD     gcc
findutil GDB        maybeprefix gdb
findutil MKRESCUE   maybeprefix grub-mkrescue

# Generate Makefile
cat > Makefile <<endcat
# Configured Makefile
#
# GENERATED FILE. DO NOT EDIT.
# Generated by $SCRIPT_PATH

srcdir      = $(printf '%q' "$srcdir")
host        = $host
target      = $target
target_cpu  = $target_cpu
target_os   = $target_os

# binutils and compilers
$(for i in "${!foundutilkeys[@]}"; do
    printf "export %-10s = %s\n" "${foundutilkeys[$i]}" "${foundutilvals[$i]}"
done)

# Additions to CPPFLAGS and similar common variables.
export CPPFLAGS         += $CPPFLAGS
export TARGET_ARCH      += $TARGET_ARCH
export LDFLAGS.kernel   += $LDFLAGS_kernel
export LDFLAGS.process  += $LDFLAGS_process

# Now that the tools and srcdir variable are configured for the target,
# defer to the template Makefile in the srcdir.
include $srcdir/Makefile.template
endcat
