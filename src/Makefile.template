.PHONY: all clean distclean
.PHONY: test processes image run
.PHONY: bootloader/bootloader

# If building for host: Run tests by default.
# If building for OS target: Build boot image by default.
ifeq "$(target)" "$(host)"
all: test
else
all: image
endif

# Search Paths
# ======================================================================

ifndef srcdir
$(error no srcdir configured. Please run configure script)
endif

# Make's search paths for dependencies
VPATH = $(srcdir) lib

# Hack: Immediately recreate source directory tree in output dir.
# This way we do not have to put explicit 'mkdir' steps before every command.
_OUTDIRS := $(shell \
	    (cd "$(srcdir)" && find -L * -type d -print0) \
	    | xargs -0 mkdir -p)

# Compilation Flags
# ======================================================================

# Basics: Warnings and debug info
ASFLAGS += -g
CFLAGS += -g -Og -Wall -Wextra

# Where to look for #include headers
CPPFLAGS += -I $(srcdir)/lib
CPPFLAGS += -I $(srcdir)/lib/arch/$(target_cpu)

# Freestanding: Compile for a minimal "freestanding" environment.
# Do not assume that a full standard C library will be available.
CFLAGS += -ffreestanding

# Use quieter output (rc), and include date information in archives (-U).
# Date information is required for Make to detect updates properly.
ARFLAGS = rc -U

# Build static executables
LDFLAGS += -static

# Auto-Generate Dependency Info
# ======================================================================

# Use C Preprocessor to generate a list of dependencies in Makefile format.
Makefile.deps: $(shell find -L "$(srcdir)" -name '*.[chS]')
	@echo "# Generating dependency information: $@"
	@echo "# Generated dependency file" > $@
	@for srcfile in `find -L "$(srcdir)" -name '*.[cS]'`; do \
		objfile=`echo $$srcfile | sed 's|$(srcdir)/\(.*\)\.[csS]|\1.o|'`; \
		$(CPP) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) \
			-M -MG -MT $$objfile $$srcfile >> $@; \
	done

include Makefile.deps

# Target Artifacts
# ======================================================================

define findobjs
$(shell find -L $(srcdir)/$1 -name '*.[csS]' \
			| sed 's|$(srcdir)/\(.*\)\.[csS]|\1.o|')
endef

# Libraries
# ----------------------------------------------------------------------

lib/libarch.a: lib/libarch.a( $(call findobjs,lib/arch/$(target_cpu)) )
lib/libcore.a: lib/libcore.a( $(call findobjs,lib/core) )
lib/libdrivers.a: lib/libdrivers.a( $(call findobjs,lib/drivers) )

# Kernel
# ----------------------------------------------------------------------

kernelobjs := $(call findobjs,kernel)

kernel/kernel: $(kernelobjs) -ldrivers -larch -lcore
kernel/kernel: LDFLAGS += $(LDFLAGS.kernel)#		From configure script
kernel/kernel: LDFLAGS += -nostartfiles -nolibc#	No default libs

# Processes
# ----------------------------------------------------------------------

processobjs := $(call findobjs,process)
processes := $(processobjs:.o=)

# For all processes, add linking flags from configure script.
$(processes): LDFLAGS += $(LDFLAGS.process)

### "Raw" Processes

# Processes with names that end in "-raw" will be treated as standalone
# "raw" code with no C runtime or standard library, similar to the kernel.
processes_raw := $(filter %-raw,$(processes))
$(processes_raw): LDFLAGS += -nostartfiles -nolibc

# "Raw" processes should also only be built when cross-compiling.
# They will probably not compile properly on the host machine.
ifneq "$(target)" "$(host)"
processes: $(processes_raw)
processes_image += $(processes_raw)
endif


bootloader/bootloader:
	nasm -f bin -I$(srcdir) $(srcdir)/bootloader/bootloader.asm -o bootloader/bootloader

# Bootable Disk Image
# ======================================================================

# Initial Ramdisk
initrd.cpio: $(processes_image)
	mkdir -p initrd/bin/
	cp $(processes_image) initrd/bin/
	cd initrd && find . \
		| sort \
		| sed 's|^\./||' \
		| cpio -ov --format=newc > ../$@

# Boot Image
bootimage.iso: grub.cfg kernel/kernel initrd.cpio bootloader/bootloader
	dd if=/dev/zero of=bootimage.img bs=512 count=2880 conv=notrunc
	mkfs.fat -F12 -R5 bootimage.img
	mmd -i bootimage.img ::/BOOT
	dd if=bootloader/bootloader of=bootimage.img conv=notrunc
	mcopy -i bootimage.img kernel/kernel ::/BOOT/KERNEL
	mcopy -i bootimage.img initrd.cpio ::/BOOT/INITRD.CPIO

# mkdir -p bootimage/boot/grub/
# cp -u kernel/kernel initrd.cpio bootimage/boot/
# cp -u $(srcdir)/grub.cfg bootimage/boot/grub/
# grub-mkrescue $(GRUBFLAGS) -o $@ bootimage/

image: bootimage.iso

# Running in an Emulator
# ======================================================================

#QEMUFLAGS += -serial file:serial.log
#QEMUFLAGS += -serial stdio
#QEMUFLAGS += -nographic
#QEMUFLAGS += -icount 5,align=on#	Slow down

# Essential boot flags: load image as hard drive
QEMUBOOT = -drive file=bootimage.img,format=raw

run: bootimage.iso
	qemu-system-$(target_cpu) $(QEMUFLAGS) $(QEMUBOOT)

debug: kernel/kernel bootimage.iso
	$(GDB) kernel/kernel -ex "target remote | \
	qemu-system-$(target_cpu) $(QEMUFLAGS) $(QEMUBOOT) -S -gdb stdio"

# Cleanup
# ======================================================================

clean:
	$(RM) -r bootimage.iso bootimage/ initrd.cpio initrd/
	$(RM) -r kernel/ lib/ process/
	$(RM) Makefile.deps

distclean: clean
	$(RM) Makefile serial.log
